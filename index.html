<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Polymer-CB Sensor with Gas Absorption</title>
  <link rel="icon" type="image/png" href="https://media.licdn.com/dms/image/v2/C4E0BAQHOhSyAWy-p0Q/company-logo_200_200/company-logo_200_200/0/1667921192659/stratuscent_logo?e=2147483647&v=beta&t=Jeo2cNHo6735I2YiT9gtucECAMuOesoJV8Z2d9zFaKw">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #f4f4f4;
    }
    h1 {
      color: #00DE93;
      margin: 2rem 1rem 1rem;
      text-align: center;
      font-size: min(2rem, 6vw);
    }
    .layout {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.25rem;
      padding: 0.5rem;
      column-gap: min(3rem, 5vw);
      max-width: min(880px, 90vw);
      margin: 0 auto;
    }
    .canvas-wrapper {
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative; /* For absolute positioning of buttons and labels */
    }
    canvas {
      border: 2px solid #00DE93;
      background: white;
      width: 100%;
      max-width: 400px;
      height: min(300px, 40vw);
    }
    .sensor-label, .graph-label {
      width: min(250px, 80vw);
      height: 24px;
      background: transparent;
      font: bold 16px sans-serif;
      text-align: center;
      line-height: 24px;
      margin: 0 auto 5px auto;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      animation: blink 1s infinite;
    }
    .sensor-label.paused, .graph-label.paused {
      animation-play-state: paused;
    }
    .sensor-label.expanding {
      animation: expand 2s ease-in-out infinite, blink 1s infinite;
    }
    .sensor-label.compressing {
      transform: scale(0.8);
      animation: blink 1s infinite;
    }
    @keyframes expand {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .graph-label span {
      position: relative;
      cursor: help;
    }
    .graph-label .tooltip {
      visibility: hidden;
      position: absolute;
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      width: min(200px, 60vw);
      text-align: center;
      z-index: 10;
    }
    .graph-label span:hover .tooltip {
      visibility: visible;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    .figure-caption {
      margin-top: 0.3rem;
      font-size: 0.95rem;
      color: #333;
      text-align: center;
    }
    .cleaning-label {
      position: absolute;
      top: 50%; /* Center vertically */
      left: 50%; /* Center horizontally */
      transform: translate(-50%, -50%); /* Center both axes */
      background: rgba(255, 255, 255, 0.8); /* Semi-transparent background for readability */
      font: bold 16px sans-serif;
      text-align: center;
      line-height: 24px;
      color: black;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      z-index: 10; /* Ensure label is above canvas */
      display: none; /* Hidden by default */
    }
    .breathe-button {
      position: absolute;
      top: 50%; /* Center vertically */
      left: 50%; /* Center horizontally */
      transform: translate(-50%, -50%); /* Center both axes */
      background: black;
      color: #FFFFFF;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 36px;
      box-sizing: border-box;
      z-index: 10; /* Ensure button is above canvas */
      display: none; /* Hidden by default during initial cycle */
      animation: breathe 1.5s ease-in-out infinite;
    }
    .breathe-button.paused {
      animation-play-state: paused;
    }
    @keyframes breathe {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    .breathe-button:hover {
      background: #333;
    }
    .breathe-button:focus {
      outline: 2px solid #00b57b;
      box-shadow: 0 0 8px rgba(0, 222, 147, 0.5);
    }
    .breathe-button:disabled {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .download-button {
      position: absolute;
      top: 50%; /* Center vertically */
      left: 50%; /* Center horizontally */
      transform: translate(-50%, -50%); /* Center both axes */
      background: black;
      color: #FFFFFF;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 36px;
      box-sizing: border-box;
      z-index: 10; /* Ensure button is above canvas */
      display: none; /* Hidden by default */
      animation: breathe 1.5s ease-in-out infinite;
    }
    .download-button.paused {
      animation-play-state: paused;
    }
    .download-button:hover {
      background: #333;
    }
    .download-button:focus {
      outline: 2px solid #00b57b;
      box-shadow: 0 0 8px rgba(0, 222, 147, 0.5);
    }
    .equation {
      margin: 2rem auto;
      max-width: min(880px, 90vw);
      background: #e0f9f1;
      padding: 1rem;
      border: 1px solid #00DE93;
      border-radius: 8px;
      text-align: center;
      font-size: 1.1rem;
    }
    .science-box {
      display: none;
      margin: 2rem auto;
      max-width: min(880px, 90vw);
      background: #fff;
      border-left: 6px solid #00DE93;
      padding: 1rem;
      font-size: 1rem;
      color: #333;
    }
    .no-js-fallback {
      display: none;
      text-align: center;
      color: #333;
      margin: 2rem auto;
      max-width: min(880px, 90vw);
    }
    .no-js-fallback.show {
      display: block;
    }
    .graph-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .y-axis-labels {
      position: absolute;
      left: -40px;
      height: min(300px, 40vw);
      width: 30px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      text-align: right;
      font-size: 12px;
      color: #333;
      padding-right: 5px;
    }
    .y-axis-labels div {
      user-select: text;
    }
    nav button, .intro-content button {
      background: black;
      color: #FFFFFF;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 36px;
      box-sizing: border-box;
    }
    nav button {
      background: transparent;
      color: #333;
      border: 2px solid #00DE93;
      border-radius: 6px;
      padding: 0.6rem 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 36px;
      box-sizing: border-box;
    }
    nav button:hover {
      background: #00DE93;
      color: #FFFFFF;
      border-color: #00DE93;
    }
    nav button:focus {
      outline: 2px solid #00b57b;
      box-shadow: 0 0 8px rgba(0, 222, 147, 0.5);
    }
    nav input {
      transition: all 0.2s ease;
    }
    nav input:hover, nav input:focus {
      outline: 2px solid #00DE93;
    }
    .intro-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .intro-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      max-width: min(500px, 90vw);
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .intro-content p {
      font-size: 1.1rem;
      color: #333;
      margin-bottom: 1rem;
    }
    .intro-logo {
      height: min(40px, 8vw);
      width: auto;
      display: block;
      margin: 0 auto 1rem auto;
      border-radius: 6px;
    }
    .feedback-toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #333;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }
    .feedback-toast.show {
      opacity: 1;
    }
    .highlight {
      outline: 3px solid #00DE93;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { outline-color: #00DE93; }
      50% { outline-color: #00b57b; }
      100% { outline-color: #00DE93; }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .layout {
        flex-direction: column;
        column-gap: 0;
        gap: 1rem;
      }
      .canvas-wrapper {
        flex: 1 1 100%;
      }
      canvas {
        max-width: 100%;
        height: min(250px, 50vw);
      }
      .sensor-label, .graph-label {
        font-size: 14px;
        width: min(200px, 90vw);
      }
      .cleaning-label {
        font-size: 14px;
      }
      .sensor-label.expanding {
        animation: expand 2s ease-in-out infinite, blink 1s infinite;
      }
      .sensor-label.compressing {
        transform: scale(0.85);
        animation: blink 1s infinite;
      }
      .sensor-label.paused, .graph-label.paused {
        animation-play-state: paused;
      }
      @keyframes expand {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
      }
      .breathe-button, .download-button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        height: 36px;
      }
      .y-axis-labels {
        left: -30px;
        width: 25px;
        font-size: 10px;
        height: min(250px, 50vw);
      }
      .figure-caption {
        font-size: 0.9rem;
      }
      .equation {
        font-size: 1rem;
        padding: 0.75rem;
      }
      .science-box {
        font-size: 0.9rem;
        padding: 0.75rem;
      }
      nav {
        flex-wrap: wrap;
        padding: 0.5rem;
        gap: 0.5rem;
      }
      nav button, .intro-content button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        height: 36px;
      }
      nav input {
        width: min(100px, 25vw);
      }
      .intro-content {
        padding: 1.5rem;
      }
      .intro-content p {
        font-size: 1rem;
      }
      .intro-logo {
        height: min(36px, 10vw);
      }
      h1 {
        font-size: 1.5rem;
      }
    }

    @media (max-width: 480px) {
      .sensor-label, .graph-label {
        font-size: 12px;
        width: min(180px, 90vw);
      }
      .cleaning-label {
        font-size: 12px;
      }
      .sensor-label.expanding {
        animation: expand 2s ease-in-out infinite, blink 1s infinite;
      }
      .sensor-label.compressing {
        transform: scale(0.9);
        animation: blink 1s infinite;
      }
      .sensor-label.paused, .graph-label.paused {
        animation-play-state: paused;
      }
      @keyframes expand {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }
      .breathe-button, .download-button {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
      }
      .y-axis-labels {
        left: -25px;
        width: 20px;
        font-size: 8px;
      }
      .figure-caption {
        font-size: 0.8rem;
      }
      .equation {
        font-size: 0.9rem;
        padding: 0.5rem;
      }
      .science-box {
        font-size: 0.8rem;
        padding: 0.5rem;
      }
      nav button, .intro-content button {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
      }
      .intro-content {
        padding: 1rem;
      }
      .intro-content p {
        font-size: 0.9rem;
      }
      .intro-logo {
        height: min(32px, 12vw);
      }
      h1 {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <nav style="position: sticky; top: 0; z-index: 1000; display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1rem; background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
    <div style="display: flex; align-items: center;">
      <img src="https://media.licdn.com/dms/image/v2/C4E0BAQHOhSyAWy-p0Q/company-logo_200_200/company-logo_200_200/0/1667921192659/stratuscent_logo?e=2147483647&v=beta&t=Jeo2cNHo6735I2YiT9gtucECAMuOesoJV8Z2d9zFaKw" alt="Noze Logo" style="height: 40px; width: auto; margin-right: 10px; border-radius: 6px;" />
      <span style="font-weight: bold; font-size: 1.2rem; color: #00DE93;">Polymerâ€“carbon black (CB) Sensor </span>
    </div>
    <div style="display: flex; align-items: center; gap: 1rem;">
      <button id="scienceButton" aria-label="Toggle scientific details"> Science</button>
      <button id="guideButton" aria-label="Start guided tour">[ðŸ“–] Guide</button>
      <button id="toggleButton" aria-label="Pause animation"> Pause</button>
      <label for="speedSlider" style="font-size: 0.85rem; color: #333;">Speed</label>
      <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="1" aria-label="Animation speed" style="width: min(120px, 30vw); accent-color: #00DE93;">
    </div>
  </nav>
  <div class="intro-overlay" id="introOverlay">
    <div class="intro-content">
      <img src="https://media.licdn.com/dms/image/v2/C4E0BAQHOhSyAWy-p0Q/company-logo_200_200/company-logo_200_200/0/1667921192659/stratuscent_logo?e=2147483647&v=beta&t=Jeo2cNHo6735I2YiT9gtucECAMuOesoJV8Z2d9zFaKw" alt="Noze Logo" class="intro-logo">
      <p><strong>Welcome!</strong> Discover how a Polymer-CB sensor detects gases by visualizing how carbon black (CB) particles move within the polymer matrix as the film expands and contracts during gas introduction and removal. In this app, pl Wait for the sensor cleaning to finish, then press the <strong>Breathe</strong> button inside the thin film animation window to introduce analytes. Wait for the breath cycle to complete, then download the breath data using the <strong>Download Data</strong> button in the graph window. Use the <strong>Pause</strong> button to stop, adjust speed with the slider, or click <strong>Science</strong> or <strong>Guide</strong> for more details.</p>
      <button id="dismissIntro">Got it!</button>
    </div>
  </div>
  <div class="feedback-toast" id="feedbackToast"></div>
  <div class="container" style="max-width: min(1200px, 95vw); margin: 0 auto; padding: 0 1rem;">
    <div class="layout" style="margin-top: 0; max-width: min(880px, 90vw); margin-left: auto; margin-right: auto;">
      <div class="canvas-wrapper">
        <div class="sensor-label" id="sensorLabel">Baseline</div>
        <canvas id="sensorCanvas" width="400" height="300" aria-label="Polymer-CB thin film animation" aria-describedby="sensorDesc"></canvas>
        <div class="cleaning-label" id="cleaningLabel"> Cleaning sensor, please wait!</div>
        <button id="breatheButton" class="breathe-button" aria-label="Introduce analytes">Breathe</button>
        <div class="figure-caption">Polymer-CB sensor thin film</div>
      </div>
      <div class="canvas-wrapper">
        <div class="graph-label" id="graphLabel"><span>Baseline<span class="tooltip"> No gas is present, sensor is in its normal state.</span></span></div>
        <div class="graph-container">
          <div class="y-axis-labels" aria-label="Resistance axis labels">
            <div>150k</div>
            <div>140k</div>
            <div>130k</div>
            <div>120k</div>
            <div>110k</div>
            <div>100k</div>
          </div>
          <canvas id="graphCanvas" width="400" height="300" aria-label="Resistance vs Time graph" aria-describedby="graphDesc"></canvas>
          <button id="downloadButton" class="download-button" aria-label="Download graph data as CSV">Download Data</button>
        </div>
        <div class="figure-caption">Resistance of thin films vs Time [s]</div>
      </div>
    </div>
    <div id="sensorDesc" style="display: none;">Animation showing Polymer-CB sensor particles reacting to gas, swelling when gas is introduced, and returning to normal when gas is removed.</div>
    <div id="graphDesc" style="display: none;">Graph showing resistance changes over time as the sensor detects gas, increasing during gas exposure and decreasing during recovery.</div>
    <div class="equation">
      Swelling â†’ CB separation â†‘ â†’ Connectivity â†“ â†’ Resistance â†‘<br />
      Î”R = R - Râ‚€ (Reversible when gas is removed gradually)
    </div>
    <div id="science" class="science-box">
      <strong>Scientific Principle:</strong><br/>
      Polymerâ€“CB (carbon black) sensors are chemiresistive devices that detect gaseous analytes by measuring changes in electrical resistance. These sensors consist of a thin film made from a swellable polymer matrix embedded with conductive carbon black (CB) particles, forming a percolative network that conducts electricity. The sensorâ€™s operation relies on the polymerâ€™s ability to swell upon analyte adsorption, which alters the CB networkâ€™s connectivity and thus the sensorâ€™s resistance.<br/><br/>
      The sensor operates in three phases: <em>Baseline</em>, <em>Exposure</em>, and <em>Recovery</em>. In the <strong>Baseline</strong> phase, no analyte is present, the polymer is unswollen, and CB particles are closely packed, forming a dense conductive network with low baseline resistance (Râ‚€). During <strong>Exposure</strong>, analyte gas molecules adsorb onto the polymer surface and diffuse into the matrix, causing the polymer to swell. This swelling increases the distance between CB particles, reducing the number of conductive pathways and increasing resistance (R). In the <strong>Recovery</strong> phase, analytes desorb, the polymer contracts, and CB particles reconnect, restoring the baseline resistance. The resistance change, Î”R = R - Râ‚€, is reversible due to the polymerâ€™s elastic properties and weak analyte binding, enabling repeated sensing cycles.<br/><br/>
      <strong>Adsorption and Desorption</strong> are central to the sensorâ€™s function. Adsorption occurs when analyte molecules bind to the polymer through intermolecular forces, such as van der Waals or hydrogen bonding, depending on the polymerâ€™s chemical structure and the analyteâ€™s properties (e.g., polarity, size). The extent of adsorption depends on analyte concentration, exposure time, and the polymerâ€™s affinity for the analyte. At low concentrations, adsorption is roughly linear, causing gradual swelling and a proportional increase in resistance. At high concentrations, adsorption may approach saturation, where the polymerâ€™s capacity to absorb more analyte is limited, stabilizing the resistance change. Desorption during Recovery reverses this process, as analyte molecules diffuse out, allowing the polymer to deswell. The sensorâ€™s sensitivity and response time vary with factors like polymer type (e.g., polar vs. non-polar), CB concentration, and analyte volatility.<br/><br/>
      <strong>Fabrication Process</strong>: The sensor is fabricated by first preparing a colloidal suspension, known as "sensor ink," consisting of a polymer solution mixed with CB particles. The polymer is dissolved in a solvent, and CB particles are added to this solution. The mixture is vigorously stirred and subjected to ultrasonicationâ€”high-frequency sound wavesâ€”to uniformly disperse the CB particles, preventing aggregation and ensuring a stable suspension. This sensor ink is then precisely dispensed onto a silicon substrate with pre-fabricated gold electrodes, chosen for their high conductivity and chemical stability. The electrodes, often patterned using photolithography to form interdigitated or parallel structures, maximize the sensing area. Dispensing techniques such as drop-casting, or printing control the inkâ€™s placement and volume. After dispensing, the ink is dried (e.g., via air drying ) to evaporate the solvent, forming a thin Polymer-CB films on the electrode surface. The filmâ€™s uniformity and thickness are critical for consistent sensor performance, ensuring a reliable percolative network for chemiresistive sensing.<br/><br/>
      The resistance change is governed by the disruption of the CB networkâ€™s conductivity. In the Baseline state, closely spaced CB particles form efficient conductive pathways. Swelling during Exposure increases inter-particle distances, breaking some pathways and raising resistance. This behavior is influenced by the polymerâ€™s elasticity, the volume fraction of CB, and the analyteâ€™s interaction strength. The sensorâ€™s design can be tailored by selecting polymers with specific chemical properties or adjusting CB loading to optimize sensitivity, selectivity, or response speed for different applications.<br/><br/>
      The response is modeled by <em>percolation theory</em>, which describes how conductivity in a composite material depends on the connectivity of conductive particles. As CB particles separate during swelling, the network approaches a percolation threshold (Ï•c), below which conductivity drops sharply. A simplified empirical percolation equation is:
      <pre style="background:#f6f6f6; padding: 0.5rem; border-radius: 4px; font-size: 0.95rem;">
      Ïƒ = Ïƒâ‚€ Ã— (Ï• - Ï•c)^t   for Ï• > Ï•c
      </pre>
      where:<br/>
      â€¢ Ïƒ is the composite conductivity<br/>
      â€¢ Ïƒâ‚€ is a scaling factor<br/>
      â€¢ Ï• is the volume fraction of CB<br/>
      â€¢ Ï•c is the percolation threshold<br/>
      â€¢ t is a critical exponent (~2.0 for 3D systems)<br/><br/>
      Polymerâ€“CB sensors have been used in high-impact applications, such as NASA JPL's E-Nose for environmental monitoring. Learn more at:
      <a href="https://electrochem.jpl.nasa.gov/?page=research-sensors" target="_blank">NASA JPL Sensor Research</a>
    </div>
    <div class="no-js-fallback show">
      <p>JavaScript is required to view the interactive Polymer-CB Sensor animation. Please enable JavaScript or view a static description at <a href="https://www.noze.ca/about">noze.ca/about</a>.</p>
    </div>
  </div>
  <script>
    // Remove no-js fallback when JS is enabled
    document.querySelector('.no-js-fallback').classList.remove('show');

    const toggleBtn = document.getElementById('toggleButton');
    const scienceBtn = document.getElementById('scienceButton');
    const scienceBox = document.getElementById('science');
    const guideBtn = document.getElementById('guideButton');
    const speedSlider = document.getElementById('speedSlider');
    const sensorLabel = document.getElementById('sensorLabel');
    const graphLabel = document.getElementById('graphLabel');
    const cleaningLabel = document.getElementById('cleaningLabel');
    const introOverlay = document.getElementById('introOverlay');
    const dismissIntro = document.getElementById('dismissIntro');
    const feedbackToast = document.getElementById('feedbackToast');
    const breatheButton = document.getElementById('breatheButton');
    const downloadButton = document.getElementById('downloadButton');

    let isRunning = true;
    let speedMultiplier = parseFloat(speedSlider.value);
    let frame = 0;
    let swell = 1.0;
    let resistance = 100000;
    let particleDensity = 1.2;
    let guideStep = 0;
    let state = "initial";
    let initialCycleCount = 0;
    let cycleProgress = 0;
    const cycleDuration = 1060; // One full cycle (Baseline â†’ Exposure â†’ Recovery)
    let cycleData = []; // Store data for the cycle triggered by Breathe button
    let hasCycleCompleted = false; // Track if a Breathe button cycle has completed

    // Dismiss intro overlay
    dismissIntro.addEventListener('click', () => {
      introOverlay.style.display = 'none';
    });

    // Breathe button event
    breatheButton.addEventListener('click', () => {
      if (isRunning && state === "baseline" && !breatheButton.disabled) {
        state = "cycle";
        cycleProgress = 0;
        cycleData = []; // Reset cycle data for new cycle
        breatheButton.disabled = true;
        downloadButton.style.display = 'none'; // Hide Download CSV button when Breathe is clicked
        showFeedback('Analytes introduced');
      }
    });
    breatheButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (isRunning && state === "baseline" && !breatheButton.disabled) {
        state = "cycle";
        cycleProgress = 0;
        cycleData = []; // Reset cycle data for new cycle
        breatheButton.disabled = true;
        downloadButton.style.display = 'none'; // Hide Download CSV button when Breathe is clicked
        showFeedback('Analytes introduced');
      }
    });

    // Download button event
    downloadButton.addEventListener('click', (event) => {
      event.preventDefault(); // Prevent any default behavior

      if (cycleData.length > 0) {
        try {
          // Generate CSV content from cycleData, which matches the graph's plotted data
          const csvContent = [
            "Time (s),Resistance (Î©)", // Header
            ...cycleData.map(data => `${data.time.toFixed(2)},${data.resistance}`)
          ].join("\n");

          // Create a Blob with the CSV content
          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

          // Create a URL for the Blob
          const url = URL.createObjectURL(blob);

          // Create a temporary link to trigger download
          const link = document.createElement('a');
          link.href = url;
          link.download = 'sensor_data.csv';
          document.body.appendChild(link);

          // Trigger the download with a slight delay to ensure it initiates
          setTimeout(() => {
            link.click();
            // Clean up
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            // Hide the download button after download
            downloadButton.style.display = 'none';
            hasCycleCompleted = false; // Reset flag so button won't reappear until next cycle

            showFeedback('CSV downloaded');
          }, 100); // 100ms delay to ensure browser handles the download
        } catch (error) {
          showFeedback('Error downloading CSV.');
        }
      } else {
        showFeedback('No data to download. Run a cycle first.');
      }
    });

    // Show feedback toast
    function showFeedback(message) {
      feedbackToast.textContent = message;
      feedbackToast.classList.add('show');
      setTimeout(() => feedbackToast.classList.remove('show'), 2000);
    }

    // Speed slider feedback
    speedSlider.addEventListener('input', e => {
      const speedValue = parseFloat(e.target.value);
      speedMultiplier = speedValue === 0 ? 0 : speedValue * speedValue * 2;
      showFeedback(speedMultiplier === 0 ? 'Animation paused' : `Speed set to ${speedMultiplier.toFixed(2)}x`);
    });

    scienceBtn.addEventListener('click', () => {
      scienceBox.style.display = scienceBox.style.display === 'block' ? 'none' : 'block';
      if (scienceBox.style.display === 'block') scienceBox.scrollIntoView({ behavior: 'smooth' });
    });

    const sensorCanvas = document.getElementById('sensorCanvas');
    const sensorCtx = sensorCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');

    // Cache grid canvas for performance (grid lines only)
    const gridCanvas = document.createElement('canvas');
    gridCanvas.width = 400;
    gridCanvas.height = 300;
    const gridCtx = gridCanvas.getContext('2d');
    function drawGrid() {
      gridCtx.strokeStyle = '#e0e0e0';
      for (let y = 0; y <= 300; y += 50) {
        gridCtx.beginPath();
        gridCtx.moveTo(0, y);
        gridCtx.lineTo(400, y);
        gridCtx.stroke();
      }
      for (let x = 0; x <= 400; x += 50) {
        gridCtx.beginPath();
        gridCtx.moveTo(x, 0);
        gridCtx.lineTo(x, 300);
        gridCtx.stroke();
      }
    }
    drawGrid();

    const fullParticles = Array.from({ length: 7000 }, () => ({ x: Math.random() * 400, y: Math.random() * 300 }));
    const gasParticles = Array.from({ length: 80 }, () => ({
      x: Math.random() * 400,
      y: Math.random() * 300,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2
    }));
    const resistanceData = [];
    const maxDataPoints = 600;

    function updateSwellAndResistance(t) {
      let tInPhase = 0;
      if (state === "initial") {
        // During initial cycle, keep resistance at 100kÎ© (Baseline only)
        swell = 1.0;
        resistance = 100000;
        particleDensity = 1.2;
      } else if (state === "cycle") {
        // Normal cycle behavior with Exposure and Recovery
        if (t < 120) { 
          swell = 1.0; 
          resistance = 100000; 
          particleDensity = 1.2; 
        } else if (t < 340) {
          tInPhase = t - 120;
          let r = 1 - Math.exp(-0.1 * tInPhase);
          swell = 1.0 + 0.2 * r;
          resistance = 100000 + 50000 * r;
          particleDensity = 1.2 - 0.9 * r;
        } else if (t < 400) { 
          swell = 1.2; 
          resistance = 150000; 
          particleDensity = 0.3; 
        } else if (t < 700) {
          tInPhase = t - 400;
          let r = 1 - Math.exp(-0.02 * tInPhase);
          swell = 1.2 - 0.2 * r;
          resistance = 150000 - 50000 * r;
          particleDensity = 0.3 + 0.9 * r;
        } else { 
          swell = 1.0; 
          resistance = 100000; 
          particleDensity = 1.2; 
        }
      } else {
        // Baseline state
        swell = 1.0;
        resistance = 100000;
        particleDensity = 1.2;
      }
    }

    function drawSensorFrame() {
      const gasDensity = swell > 1.05 ? 80 : 0;

      sensorCtx.clearRect(0, 0, 400, 300);
      sensorCtx.fillStyle = '#e8f7f3';
      sensorCtx.fillRect(0, 0, 400, 300);

      for (let i = 0; i < gasDensity; i++) {
        const p = gasParticles[i];
        p.x += p.vx / speedMultiplier;
        p.y += p.vy / speedMultiplier;
        if (p.x < 0 || p.x > 400) p.vx *= -1;
        if (p.y < 0 || p.y > 300) p.vy *= -1;
        sensorCtx.beginPath();
        sensorCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        sensorCtx.fillStyle = 'rgba(0, 180, 130, 0.4)';
        sensorCtx.fill();
      }
      const count = Math.min(Math.floor(fullParticles.length * particleDensity), fullParticles.length);
      for (let i = 0; i < count; i++) {
        const p = fullParticles[i];
        const cx = 200 + (p.x - 200) * swell;
        const cy = 150 + (p.y - 150) * swell;
        sensorCtx.beginPath();
        sensorCtx.arc(cx, cy, 1.2, 0, Math.PI * 2);
        sensorCtx.fillStyle = '#333';
        sensorCtx.fill();
      }
    }

    function drawGraphFrame() {
      let bgColor;
      if (state !== "initial" && cycleProgress >= 120 && cycleProgress < 400) {
        bgColor = 'rgb(255, 220, 235)';
      } else if (state !== "initial" && cycleProgress >= 400 && cycleProgress < 700) {
        const progress = (cycleProgress - 400) / 300;
        const green = Math.round(220 + (255 - 220) * progress);
        const blue = Math.round(235 + (255 - 235) * progress);
        bgColor = `rgb(255, ${green}, ${blue})`;
      } else {
        bgColor = 'rgb(255, 255, 255)';
      }
      let labelText = '';
      let labelColor = '#0000FF';
      if (state === "initial") {
        labelText = 'Cleaning...';
        labelColor = '#0000FF';
      } else if (cycleProgress < 120 || cycleProgress >= 700) {
        labelText = 'Baseline';
        labelColor = '#0000FF';
      } else if (cycleProgress >= 120 && cycleProgress < 400) {
        labelText = 'Analyte Introduced';
        labelColor = '#FF0000';
      } else if (cycleProgress >= 400 && cycleProgress < 700) {
        labelText = 'Analytes Removed (Recovery)';
        labelColor = '#008000';
      }

      graphCtx.clearRect(0, 0, 400, 300);
      graphCtx.fillStyle = bgColor;
      graphCtx.fillRect(0, 0, 400, 300);
      graphCtx.drawImage(gridCanvas, 0, 0);

      // Update resistanceData for plotting (capped at maxDataPoints)
      resistanceData.push(resistance);
      if (resistanceData.length > maxDataPoints) resistanceData.shift();

      // Plot the graph using resistanceData
      if (resistanceData.length >= 2) {
        graphCtx.beginPath();
        graphCtx.strokeStyle = '#00DE93';
        graphCtx.lineWidth = 2;
        for (let i = 0; i < resistanceData.length - 1; i++) {
          const x1 = i * (400 / maxDataPoints);
          const y1 = 300 - (resistanceData[i] - 95000) / 500;
          const x2 = (i + 1) * (400 / maxDataPoints);
          const y2 = 300 - (resistanceData[i + 1] - 95000) / 500;
          if (i === 0) graphCtx.moveTo(x1, y1);
          const xc = (x1 + x2) / 2;
          const yc = (y1 + y2) / 2;
          graphCtx.quadraticCurveTo(xc, yc, x2, y2);
        }
        graphCtx.stroke();
      } else {
        graphCtx.fillStyle = '#333';
        graphCtx.font = '14px sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.fillText('Waiting for resistance data...', 200, 150);
      }

      // Draw moving label on graph line
      if (resistanceData.length > 0) {
        const lastX = (resistanceData.length - 1) * (400 / maxDataPoints);
        const lastY = 300 - (resistanceData[resistanceData.length - 1] - 95000) / 500;

        // Draw white background for label
        const labelWidth = labelText.length * 8;
        const labelHeight = 20;
        const labelX = Math.max(10, Math.min(lastX - labelWidth / 2, 390 - labelWidth));
        const labelY = lastY - 10;
        graphCtx.fillStyle = 'white';
        graphCtx.globalAlpha = 1.0;
        graphCtx.fillRect(labelX - 5, labelY - 15, labelWidth + 10, labelHeight);
        graphCtx.globalAlpha = 1.0;

        // Draw label text
        graphCtx.font = 'bold 14px sans-serif';
        graphCtx.fillStyle = labelColor;
        graphCtx.textAlign = 'center';
        graphCtx.fillText(labelText, labelX + labelWidth / 2, labelY);

        // Highlight current point
        graphCtx.beginPath();
        graphCtx.arc(lastX, lastY, 4, 0, Math.PI * 2);
        graphCtx.fillStyle = '#FF5733';
        graphCtx.fill();
      }

      // Draw axis labels
      graphCtx.fillStyle = '#00DE93';
      graphCtx.font = '14px sans-serif';
      graphCtx.save();
      graphCtx.translate(20, 150);
      graphCtx.rotate(-Math.PI / 2);
      graphCtx.textAlign = 'center';
      graphCtx.fillText('Resistance (Î©)', 0, 0);
      graphCtx.restore();
      graphCtx.fillText('', 330, 290);
    }

    // Guided tour
    guideBtn.addEventListener('click', () => {
      guideStep = 0;
      runGuide();
    });

    function runGuide() {
      document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
      
      const steps = [
        { element: sensorCanvas, message: 'Step 1: Watch the sensor particles swell when gas is introduced.' },
        { element: graphCanvas, message: 'Step 2: See how resistance changes on the graph as gas affects the sensor.' },
        { element: speedSlider, message: 'Step 3: Adjust the animation speed with this slider.' },
        { element: breatheButton, message: 'Step 4: Press the Breathe button inside the thin film animation window to introduce analytes after the initial cycle.' },
        { element: downloadButton, message: 'Step 5: After a Breathe cycle completes, click Download CSV to save the graph data.' },
        { element: scienceBtn, message: 'Step 6: Click Science to learn more about how the sensor works!' },
        { element: null, message: 'Tour complete! Explore freely.' }
      ];

      if (guideStep < steps.length) {
        const step = steps[guideStep];
        if (step.element) {
          step.element.classList.add('highlight');
          showFeedback(step.message);
        } else {
          showFeedback(step.message);
        }
        guideStep++;
        setTimeout(runGuide, 5000); // Slowed down to 5 seconds per step
      }
    }

    function animate(timestamp) {
      if (!isRunning || speedMultiplier === 0) return; // Pause if speed is 0

      // Update cycle progress for initial cycle or button-triggered cycle
      if (state === "initial") {
        cycleProgress++;
        if (cycleProgress >= cycleDuration) {
          initialCycleCount++;
          cycleProgress = 0;
          if (initialCycleCount >= 1) {
            state = "baseline";
            cleaningLabel.style.display = 'none'; // Hide cleaning label
            breatheButton.style.display = 'block'; // Show Breathe button
            breatheButton.disabled = false; // Enable the button
          }
        }
      } else if (state === "cycle") {
        cycleProgress++;
        // Store data for the cycle, matching what is plotted on the graph
        const time = cycleProgress / 24; // Convert frames to seconds (assuming 24 fps)
        cycleData.push({ time: time, resistance: resistance });
        if (cycleProgress >= cycleDuration) {
          state = "baseline";
          cycleProgress = 0;
          breatheButton.disabled = false;
          hasCycleCompleted = true; // Mark that a cycle has completed
          downloadButton.style.display = 'block'; // Show the download button
        }
      }

      // Show "Cleaning sensor, please wait!" label and hide Breathe button during initial cycle
      if (state === "initial") {
        cleaningLabel.style.display = 'block';
        breatheButton.style.display = 'none';
      } else {
        cleaningLabel.style.display = 'none';
        if (state === "baseline") {
          breatheButton.style.display = 'block';
        }
      }

      // Update values and labels based on cycle progress
      if (state === "initial" || state === "cycle") {
        updateSwellAndResistance(cycleProgress);
      } else if (state === "baseline") {
        swell = 1.0;
        resistance = 100000;
        particleDensity = 1.2;
        cycleProgress = 0; // Keep cycleProgress at 0 in baseline to match reference behavior
        if (!hasCycleCompleted) {
          downloadButton.style.display = 'none'; // Hide download button if no cycle has completed
        }
      }

      // Update sensor and graph labels
      let phaseText = '';
      let sensorText = '';
      let phaseTooltip = '';
      let phaseColor = '#0000FF';
      sensorLabel.classList.remove('expanding', 'compressing');
      if (state === "initial") {
        phaseText = 'Cleaning...';
        sensorText = 'Cleaning...';
        phaseTooltip = 'Sensor is initializing, please wait.';
        phaseColor = '#0000FF';
      } else if (state === "baseline" || cycleProgress < 120 || cycleProgress >= 700) {
        phaseText = 'Baseline';
        sensorText = 'Baseline';
        phaseTooltip = 'No gas is present, sensor is in its normal state.';
      } else if (cycleProgress >= 120 && cycleProgress < 400) {
        phaseText = 'Analyte Introduced';
        sensorText = 'Expansion of thin films';
        phaseTooltip = 'Gas is added, causing the sensor to swell and resistance to increase.';
        phaseColor = '#FF0000';
        sensorLabel.classList.add('expanding');
      } else if (cycleProgress >= 400 && cycleProgress < 700) {
        phaseText = 'Analytes Removed (Recovery)';
        sensorText = 'Compression of thin films';
        phaseTooltip = 'Gas is removed, sensor returns to normal, resistance decreases.';
        phaseColor = '#008000';
        sensorLabel.classList.add('compressing');
      }
      graphLabel.innerHTML = `<span>${phaseText}<span class="tooltip">${phaseTooltip}</span></span>`;
      graphLabel.style.color = phaseColor;
      sensorLabel.textContent = sensorText;
      sensorLabel.style.color = phaseColor;

      drawSensorFrame();
      drawGraphFrame();
      frame++;
      requestAnimationFrame(animate);
    }

    function toggleAnimation() {
      isRunning = !isRunning;
      toggleBtn.textContent = isRunning ? 'Pause' : 'Start';
      toggleBtn.setAttribute('aria-label', isRunning ? 'Pause animation' : 'Start animation');
      showFeedback(isRunning ? 'Animation started' : 'Animation paused');
      if (isRunning) {
        sensorLabel.classList.remove('paused');
        graphLabel.classList.remove('paused');
        breatheButton.classList.remove('paused');
        downloadButton.classList.remove('paused');
        if (speedMultiplier !== 0) requestAnimationFrame(animate);
      } else {
        sensorLabel.classList.add('paused');
        graphLabel.classList.add('paused');
        breatheButton.classList.add('paused');
        downloadButton.classList.add('paused');
      }
    }

    toggleBtn.addEventListener('click', toggleAnimation);
    toggleBtn.addEventListener('keydown', e => {
      if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        toggleAnimation();
      }
    });
    speedSlider.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        const step = e.key === 'ArrowLeft' ? -0.1 : 0.1;
        speedSlider.value = Math.min(2, Math.max(0, parseFloat(speedSlider.value) + step));
        const speedValue = parseFloat(speedSlider.value);
        speedMultiplier = speedValue === 0 ? 0 : speedValue * speedValue * 2;
        showFeedback(speedMultiplier === 0 ? 'Animation paused' : `Speed set to ${speedMultiplier.toFixed(2)}x`);
      }
    });

    requestAnimationFrame(animate);
  </script>
</body>
</html>